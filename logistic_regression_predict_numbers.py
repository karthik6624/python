# -*- coding: utf-8 -*-
"""Logistic_Regression_Predict_numbers.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lhWUwlXSjXhArsBGqdYv3rwCzchv6070

# Logistic Regression/ Predicting Numbers in images
"""

# Commented out IPython magic to ensure Python compatibility.
#Importing Libraries and their associated methods
from sklearn.datasets import load_digits                       #importing dataset(load_digits)
from sklearn.model_selection import train_test_split           #importing for training our model and also for testing
import numpy as np                                             #importing numpy
import matplotlib.pyplot as plt                                #importing matplot for graphical represenatation
import seaborn as sns                                          #seaborn for data represenatation in a square.
from sklearn import metrics                                    #including all metrics required.
# %matplotlib inline                                             #the plotting will be done within the cell.
digits=load_digits()                                           #storing load_digits in digits variable.

digits

print(f"Image Data Shape {digits.data.shape}")       #1797 is total data samples and 64 is representing number of pixel.
print(f"Label Data Shape {digits.target.shape}")     #1797 is total data samples which is given in  a row.

#Displaying some of the images and labels
import numpy as np                                           #importing numpy
import matplotlib.pyplot as plt                              #importing matplot library

plt.figure(figsize=(20,4))                           #creating figure of size 20units along x-axis and 4 units along y-axis. 
for index, (image, label) in enumerate(zip(digits.data[0:5], digits.target[0:5])):   
                                     #enumerate is used to extract the label and zip is used to zipping the values in the form of list.
    plt.subplot(1,5, index+1)              #used for plotting more than one images(1 row and 5 columns)
    plt.imshow(np.reshape(image, (8,8)), cmap=plt.cm.gray)           #reshaping the dimension of image consisting the pixels. by 8*8 square and giving gray colour for label.
    plt.title(f"Training: {label}", fontsize=20 )                    #for labelling and font size

#Divide dataset into training and testing sets
from sklearn.model_selection import train_test_split                 #importing for training and testing the data values
x_train, x_test, y_train, y_test=train_test_split(digits.data, digits.target, test_size=0.23, random_state=2)   #23% is used for testing and for randomness we use random state.

print(x_train.shape)          #showing size of x train

print(y_train.shape)             #showing size of y train

print(x_test.shape)                #showing size of x test

print(y_test.shape)               #showing size of y test

#Import the logistic refression model, making the instance of that model and training it
from sklearn.linear_model import LogisticRegression         
reg=LogisticRegression()                                #storing the dataset in variable reg
reg.fit(x_train, y_train)                                #fit method gives updated values of the weights and bias.

#Predicting the output of the first element of the test set
print(reg.predict(x_test[0].reshape(1,-1)))            #predicting and reshaping x test value since it has multiple features.

reg.predict(x_test[0:10])                                 #predicting x test values in between 0 and 10 indices.

#Predicting the entire DataSet
pred=reg.predict(x_test)                           #for predicting the whole x test values

#Determining the accuracy of the model
score=reg.score(x_test, y_test)                        #storing the reg.score data set in score variable 
print(score)    #print the data stored.

#Representation the confusion matrix in a heatmap
from sklearn.metrics import confusion_matrix
cm=confusion_matrix(y_test, pred)                                    #storing the confusion_matrix data set in variable cm
# print(cm)
plt.figure(figsize=(20,9))                  #plotting figure and making into size of 20units in  x axis and 9 units in y axis.
sns.heatmap(cm, annot=True, fmt=".3f", linewidths=.5, square=True, cmap='Blues_r')     #heat map is a method in seaborn method  ,annot stands for annotations(if u want to write something in cell),
plt.ylabel('Actual Label')                #marking   y-label  as actual label
plt.xlabel('Predicted Label')               #marking x-label as predicted label
all_sample_title=f"Accuracy Score: {score}"        #storing score dataset in variable all_sample_title.
plt.title(all_sample_title, size=15)                     #plotting data stored

index=0                                             #index is intialised with 0.
classifiedIndex=[]
for predict, actual in zip(pred, y_test):     #zippping the valuesof pedict and y_test values.
    if predict!=actual:                       #predicted value is not equal to acctual values
        classifiedIndex.append(index)                    #appending the for loop values.
    index+=1
plt.figure(figsize=(20,4))                                 #plotting the graphs in 20*4 format
for plotindex, wrong in enumerate(classifiedIndex[0:4]):             #enumerating for getting index   for the initial 4 values of classified index
    plt.subplot(1,4, plotindex + 1)       #for more than one graph plotting
    plt.imshow(np.reshape(x_test[wrong], (8,8)), cmap=plt.cm.gray)             #xtest values which are wrong.
    plt.title(f"Predicted: {pred[wrong]}, Actual: {y_test[wrong]}", fontsize=20)      #wrong predict values and wrong y_tets values.

